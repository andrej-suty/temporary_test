# Python Semantic Release Demo

This project demonstrates how to use `python-semantic-release` to automate versioning and releases for a Python package based on commit messages.

## Project Structure

- `src/demo_package/`: Contains the example Python package.
  - `__init__.py`: Package initializer.
  - `main.py`: Simple module with functions.
- `tests/`: Contains basic unit tests using `pytest`.
- `pyproject.toml`: Configures the project, build system, and `python-semantic-release`.
- `.github/workflows/release.yml`: (To be added) GitHub Actions workflow for automated releases.
- `CHANGELOG.md`: (Will be generated by semantic-release) Contains the release history.

## Setup

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/your_username/semantic_release_demo.git # Replace with actual URL
    cd semantic_release_demo
    ```

2.  **Create a virtual environment and install dependencies:**
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows use `venv\Scripts\activate`
    pip install -e .[dev] # Install in editable mode with dev dependencies
    ```
    *(Note: We still need to define the `[project.optional-dependencies]` for `dev` in `pyproject.toml`)*

3.  **Install semantic-release:**
    ```bash
    pip install python-semantic-release
    ```

## How Semantic Release Works

`python-semantic-release` analyzes commit messages since the last release to determine the next version number and generate a changelog. It follows the [Conventional Commits](https://www.conventionalcommits.org/) specification.

- **`fix:`** commits trigger a **patch** release (e.g., `0.1.0` -> `0.1.1`).
- **`feat:`** commits trigger a **minor** release (e.g., `0.1.0` -> `0.2.0`).
- Commits with `BREAKING CHANGE:` in the footer or `!` after the type/scope (e.g., `feat!:`) trigger a **major** release (e.g., `0.1.0` -> `1.0.0`).
- Other commit types (`chore:`, `docs:`, `style:`, `refactor:`, `test:`, `build:`, `ci:`) do not trigger a release by default.

## Demo: Triggering Releases

1.  **Make a change:** Modify a function in `src/demo_package/main.py`. For example, update the `feature_status` function.

2.  **Commit with a semantic message:**
    - **Patch release:**
      ```bash
      git add .
      git commit -m "fix: Correct typo in feature status message"
      ```
    - **Minor release:**
      ```bash
      git add .
      git commit -m "feat: Add user configuration option to greeting"
      # (Implement the feature first!)
      ```
    - **Major release (Breaking Change):**
      ```bash
      git add .
      git commit -m "feat!: Change add function to handle strings, breaking compatibility" -m "BREAKING CHANGE: The add function now concatenates strings instead of adding numbers."
      # (Implement the breaking change first!)
      ```

3.  **Run semantic-release (locally for testing):**
    *(Ensure you have committed your changes and potentially tagged the initial version: `git tag v0.1.0`)*
    ```bash
    semantic-release version # Check the next version without making changes
    semantic-release publish # Determine version, generate changelog, build, commit, tag, and potentially upload
    ```
    *(Note: The `publish` command might fail locally if not configured for a specific CI environment or if Git credentials aren't set up correctly for pushing tags/commits.)*

4.  **Check the results:**
    - Look at the updated `pyproject.toml` for the new version.
    - Check the generated `CHANGELOG.md`.
    - View the new tag created in your Git history (`git tag`).

## GitHub Actions Workflow (Coming Soon)

A `.github/workflows/release.yml` file will be added to automate the release process on every push to the `main` branch where a release is warranted.

## Contributing

Feel free to experiment with changes and commit messages to see how semantic-release behaves. Remember to replace the placeholder GitHub URLs in `pyproject.toml` and this README with your actual repository URL.
